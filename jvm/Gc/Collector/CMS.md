## CMS收集器

CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器
![ParNew](./../../pic/GC/Collector/CMS.png)

* 应用场景

	对于要求服务器响应速度的应用上。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短，以很用户带来较好的体验。

* 工作过程

	CMS收集器是基于**标记-清除**算法实现的，它的动作过程分为以下几个步骤

	* **初始标记（CMS initial mark）**

	在这个阶段，需要虚拟机停顿正在执行的任务，官方叫法为STW（Stop The Word）。这个过程从垃圾回收的"根对象（GC Roots）开始"，只扫描到能够和"根对象"直接关联的对象，并作标记。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要"Stop The World"

	* **并发标记（CMS concurrent marking）**

	这个阶段紧随初始化标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。并发标记阶段就是进行GC Roots Tracing的过程

	* **并发预清理（CMS concurrent precleaning）**

	并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段进入老年代的对象（可能会有一些对象从新生代晋升到老年代，或者有一些对象被分配到老年代）。通过重新扫描，减少下一阶段"重新标记"的工作，因为下一阶段会 "Stop The World"

	* **重新标记（CMS remark）**

	重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，仍然需要"Stop The World"

	* **并发清除（CMS concurrent sweep）**

	清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行

	* **并发重置（CMS concurrent reset）**

	这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收

* 优点

	* 并发收集，低停顿

	由于在整个过程中最耗时的并发标记和并发清除过程收集器程序都可以和用户线程一起工作，所以总体来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

* 缺点

	* 对CPU资源非常敏感
	
	在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程使用应用程序变慢，总吞吐量会降低。

	* 无法处理浮动垃圾

	CMS收集器无法处理浮动垃圾，可能出现"Concurrent Mode Failure"失败而导致另一次Full GC的产生。

	由于CMS并发清除阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉，这一部分垃圾就称为"浮动垃圾"。

	由于在垃圾收集阶段用户线程还需要运行，那就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次"Concurrent Mode Failure"失败，这是虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。

	* 产生大量空间碎片

	CMS是一款基于"标记-清除"算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。

	空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。

	为了解决这个问题，CMS提供了一个开关参数，用于在CMS顶不住要进行Full GC的时候开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片没有了，但是停顿的时间变长了。